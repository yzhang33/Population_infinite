"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var HTTPErrors_1 = require("./HTTPErrors");
var utils_1 = require("./utils");
/**
 * A class representing a Runway Hosted Model. This is the main interface provided by
 * this package. Exposes two main methods for interfacing with a model.
 *
 * - `info()`
 * - `query(input)`
 *
 * Exposes two helper methods for checking the "awake" status of a hosted model.
 *
 * - `isAwake()`
 * - `waitUntilAwake()`
 */
var HostedModel = /** @class */ (function () {
    /**
     * ```typescript
     * const model = new HostedModel({
     *  url: 'https://my-model.hosted-models.runwayml.cloud/v1',
     *  token: 'my-secret-token', # token is only required for private models
     * })
     * ```
     */
    function HostedModel(config) {
        if (typeof config !== 'object')
            throw new HTTPErrors_1.InvalidArgumentError('config');
        this.url = config.url;
        this.token = config.token || null;
        this.headers = {
            Accept: 'application/json',
            'Content-Type': 'application/json',
        };
        if (this.token)
            this.headers['Authorization'] = "Bearer " + this.token;
        this.responseCodesToRetry = [502, 429];
        if (!this.isValidV1URL(this.url))
            throw new HTTPErrors_1.InvlaidURLError();
        // Wake up the model during construction because it will probably be used soon
        this.root()
            .then(function (result) { return result; })
            .catch(function (err) { return err; });
    }
    /**
     * Return info about the input/output spec provided by the model. Makes a GET request
     * to the /v1/info route of a hosted model under the hood.
     */
    HostedModel.prototype.info = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.requestHostedModel({
                        url: this.url + "/info",
                        method: 'GET',
                        headers: this.headers,
                    })];
            });
        });
    };
    /**
     * Run the model on your input and produce an output. This is how you "run" the model.
     * @param input An object containing input parameters to be sent to the model.
     * Use the [[info]] method to get the correct format for this object, as each model
     * expects different inputs.
     */
    HostedModel.prototype.query = function (input) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (typeof input !== 'object')
                    throw new HTTPErrors_1.InvalidArgumentError('input');
                return [2 /*return*/, this.requestHostedModel({
                        url: this.url + "/query",
                        method: 'POST',
                        headers: this.headers,
                        data: input,
                    })];
            });
        });
    };
    /**
     * Returns `true` if this model is awake, `false` if it is still waking up.
     * See Awake, Awakening, and Awake in the
     * [Hosted Models docs](https://learn.runwayml.com/#/how-to/hosted-models?id=asleep-awakening-and-awake-states).
     */
    HostedModel.prototype.isAwake = function () {
        return __awaiter(this, void 0, void 0, function () {
            var root;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.root()];
                    case 1:
                        root = _a.sent();
                        return [2 /*return*/, root.status === 'running'];
                }
            });
        });
    };
    /**
     * Returns a promise that will resolve once the model is awake. This method is never
     * required, as [[info]] and [[query]] will always return results eventually, but it can be
     * useful for managing UI if you want to postpone making [[info]] and [[query]] requests
     * until you know that they will resolve more quickly.
     *
     * ```typescript
     * // This is pseudo code
     * const model = new HostedModel({
     *  url: 'https://my-model.hosted-models.runwayml.cloud/v1',
     *  token: 'my-secret-token', # token is only required for private models
     * })
     * // Enter some loading state in the UI.
     * loading(true)
     * await model.waitUntilAwake() // This method is never required, but can sometimes be useful
     * loading(false)
     *
     * while (true) {
     *  const input = getSomeInput()
     *  const output = await model.query(input)
     *  doSomething(output)
     * }
     * ```
     *
     * @param pollIntervalMillis [[waitUntilAwake]] The rate that this function will poll
     * the hosted model endpoint to check if it is awake yet.
     */
    HostedModel.prototype.waitUntilAwake = function (pollIntervalMillis) {
        if (pollIntervalMillis === void 0) { pollIntervalMillis = 1000; }
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        (function () { return __awaiter(_this, void 0, void 0, function () {
                            var awake, err_1;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        _a.trys.push([0, 5, , 6]);
                                        _a.label = 1;
                                    case 1:
                                        if (!true) return [3 /*break*/, 4];
                                        return [4 /*yield*/, this.isAwake()];
                                    case 2:
                                        awake = _a.sent();
                                        if (awake) {
                                            resolve();
                                            return [2 /*return*/];
                                        }
                                        return [4 /*yield*/, utils_1.delay(pollIntervalMillis)];
                                    case 3:
                                        _a.sent();
                                        return [3 /*break*/, 1];
                                    case 4: return [3 /*break*/, 6];
                                    case 5:
                                        err_1 = _a.sent();
                                        reject(err_1);
                                        return [3 /*break*/, 6];
                                    case 6: return [2 /*return*/];
                                }
                            });
                        }); })();
                    })];
            });
        });
    };
    HostedModel.prototype.root = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.requestHostedModel({
                        url: this.url + "/",
                        method: 'GET',
                        headers: this.headers,
                    })];
            });
        });
    };
    HostedModel.prototype.requestHostedModel = function (config) {
        return __awaiter(this, void 0, void 0, function () {
            var result, err_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, utils_1.requestWithRetry(this.responseCodesToRetry, config)];
                    case 1:
                        result = _a.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        err_2 = _a.sent();
                        throw new HTTPErrors_1.NetworkError(err_2.code);
                    case 3:
                        if (this.isHostedModelResponseError(result)) {
                            if (result.status === 401)
                                throw new HTTPErrors_1.PermissionDeniedError();
                            else if (result.status === 404)
                                throw new HTTPErrors_1.NotFoundError();
                            else if (result.status === 500)
                                throw new HTTPErrors_1.ModelError();
                            throw new HTTPErrors_1.UnexpectedError();
                        }
                        return [2 /*return*/, result.data];
                }
            });
        });
    };
    HostedModel.prototype.isHostedModelResponseError = function (response) {
        return (!response.headers['content-type'].includes('application/json') ||
            !(response.status >= 200 && response.status < 300));
    };
    HostedModel.prototype.isValidV1URL = function (url) {
        return /^https{0,1}:\/\/.+\.runwayml\.cloud\/v1/.test(url);
    };
    return HostedModel;
}());
exports.HostedModel = HostedModel;
//# sourceMappingURL=HostedModel.js.map